#!/usr/bin/env node
'use strict'

/*
Fix for SVGs generated by OpenJSCAD v1.x.

This script runs the keyboard plate generator to generate a .svg file, reverses
the order of any <path> elements and adds fill and outline params to each path.

*/

const openJscadCommand = 'openjscad'
const openJscadScript = 'sheet_keyboard.jscad'
const inputSvgFilename = "sheet_keyboard.svg"
const outputSvgFilename = "sheet_keyboard.fixed.svg"

const pathElementAdditions = 'stroke="black" fill="lightgray" stroke-width="0.5"'

var argv = require('yargs').option('noPathReorder', {
  alias: 'n',
  type: 'boolean',
  description: 'Do not automatically re-order <path> elements by size'
})
.usage('Build a keyboard plate and post-process the resultant SVG\n\nUsage: $0 [options]')
.argv

var fs = require('fs')

const { spawnSync } = require('child_process')
const svgExport = spawnSync(openJscadCommand, [openJscadScript, '-o', inputSvgFilename])

if (svgExport.error)
  throw Error(svgExport.error)

console.log(svgExport.stdout.toString())

if (svgExport.stderr.length)
  console.log(`stderr: ${svgExport.stderr.toString()}`)

var svgSource = fs.readFileSync(inputSvgFilename, 'utf8')

var gElementsMatch = svgSource.match(/(\<g>.+\<\/g>)/s)

if (!gElementsMatch || gElementsMatch[0].length < 1)
  throw Error(`Could not find any <g> elements in ${inputSvgFilename}`)

/* handle multiple <g> tags */
var gElements = gElementsMatch[0]
  .replace(/^\<g>/, '')    // remove leading
  .replace(/\<\/g>$/, '')  // remove trailing
  .split(/\<\/g>\s*\<g>/s) // split on "</g><g>" boundary

console.log(`Fixing ${gElements.length} <g> elements`)

var gElementsRewrite = gElements.map(function (gElement) {

  // Separate each path element
  var pathElements = gElement
    .split(/(\<path\s+d=\".*\"\/\>)/)
    .filter(part => !part.match(/^\s+$/))

  console.log(`Fixing ${pathElements.length} <path> elements`)

  /*
  The order of the paths often needs to be arranged so the largest ones (the
  baground/outlines) appear before the smaller ones (the key cutouts), otherwise
  we won't be able to see the key cutouts.

  We do this by sorting all the paths with the "largest" Line path position
  value (the largest "Ldddd.dddd" of a path,
  https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths), and making
  sure the largest paths appear first.
  */

  if (argv.noPathReorder) {
    console.log("Will not re-order path elements")
  } else {
    pathElements = pathElements.sort(function(firstEl, secondEl) {
      let getMax = function(element) {
        return [...element.matchAll(/L([\d\.]+)/g)]
          .map(m => parseFloat(m[1]))
          .reduce(function (a, b) { return Math.max(a, b) })
      }

      return getMax(secondEl) - getMax(firstEl)
    })
  }

  // add fill and stroke to each <path>
  return pathElements.map(function (pathElement) {
    return pathElement.replace(/path\s+d=/, 'path ' + pathElementAdditions + ' d=')
  })
})

// Write the new svg file with changed <g>/<path> elements
fs.writeFileSync(
  outputSvgFilename,
  svgSource.replace(
    gElementsMatch[0],
    gElementsRewrite.map(pathElements => "<g>" + pathElements.join("\n") + "</g>").join("\n")
  )
)

console.log(`Wrote ${outputSvgFilename}`)
